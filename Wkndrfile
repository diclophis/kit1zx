#

if false

Wkndr.play { |gl|
  player_position = [0.0,0.0,0.0]
  camera_position = [7.0,7.0,9.0]
  fovy = 30.0

  gl.lookat(1, *camera_position, *player_position, fovy)

  flowers = []

  flowers << Model.new("resources/tri001.obj", "", 1.0)
  flowers << Model.new("resources/cube.obj", "", 0.5)
  flowers << Model.new("resources/road-corner.obj", "resources/road-corner.mtl", 0.76)
  flowers << Model.new("resources/rando.obj", "", 0.76)
  flowers << Model.new("resources/coin.obj", "", 2.0)

  #flower = Model.new("resources/Prop_Fence_Gate_1.obj", "", 33.0)

  total_msg = 0
  flower_index = 0

  gl.event { |typed_msg|
    total_msg += 1
  }

  gl.update { |global_time, delta_time|
    gl.drawmode {
      gl.threed {
        #flower.deltas(0.0001, 0.0001, 0.0001)
        #flower.deltap(player_position[0], player_position[1], player_position[2])
        flower = flowers[(flower_index) % flowers.length]

        #flower.deltar(Math.cos(-global_time * 0.5), Math.sin(global_time), Math.cos(global_time * 1.0), global_time * 33.0)
        flower.deltar(0, 1, 0, global_time * -100.0)
        flower.draw(false)
      }

      gl.twod {
        gl.draw_fps(0, 0)
        gl.button(50.0, 50.0, 250.0, 20.0, "maze #{total_msg}") {
          gl.emit({"x" => "y"})
          flower_index += 1
        }
      }
    }
  }
}

else

Wkndr.play { |gl|
  srand(2)

  size = 0.1
  shapes = {}
  shape_translate_table = {}
  enforce_bounds = true

  16.times { |i|
    ii = begin
      case i
        when 1
          8
        when 2
          7
        when 3
          9
        when 4
          6
        when 5
          12
        when 6
          11
        when 7
          3
        when 8
          5
        when 9
          13
        when 10
          14
        when 11
          4
        when 12
          10
        when 13
          1
        when 14
          2
        when 15
          0
      else
        nil
      end
    end
    
    if ii
      #ii = 0
      shape_translate_table[i] = ii
      shape_file = "resources/shape-#{ii}.obj"
      #log!(:shape, shape_file)
      shapes[i] = Model.new(shape_file, "", 1.0)
    end
  }

  maze_s = 10
  braid = 0
  weave = 0
  sparse = 0

  ## generate a 10x10 orthogonal maze and print it to the console
  maze = Theseus::OrthogonalMaze.generate(:width => maze_s, :height => maze_s, :braid => braid, :weave => weave, :wrap => "xy", :sparse => 100)

  cube = Cube.new(size, size, size, 1.0)

  player_position = [0.0,0.125,0.0]
  player_velocity = [0.0, 0.0, 0.0]
  camera_position = [0.0,1.5,0.0]

  fovy = 60.0
  maze_draw_distance = 3

  gl.lookat(1, *camera_position, *player_position, fovy)

  total_msg = 0
  player_at_shape = nil
  at_left_right_limit = nil
  at_up_down_limit = nil

  gl.event { |typed_msg|
    total_msg += 1
  }

  gl.update { |global_time, delta_time|
    gl.drawmode {
      gl.threed {
        got_lr = got_ud = false

        nx = player_position[0] + (player_velocity[0] * delta_time)
        ny = player_position[2] + (player_velocity[2] * delta_time)

        px = ((nx - 0).round)
        py = ((ny - 0).round)
        #log!(:pxpy, px, py)

        allow_up = false
        allow_down = false
        allow_left = false
        allow_right = false

        player_at_shape = nil

        if px>=0 && px<maze_s && py>=0 && py<maze_s
          player_at_shape_cell = maze[px.to_i, py.to_i]
          player_at_shape = shape_translate_table[(player_at_shape_cell & Theseus::Maze::PRIMARY)]
        end

        case player_at_shape
          when 0
            allow_up = allow_down = allow_left = allow_right = true
          when 1
            allow_down = allow_left = allow_right = true
          when 2
            allow_up = allow_left = allow_right = true
          when 3
            allow_up = allow_down = allow_left = true
          when 4
            allow_up = allow_down = allow_right = true
          when 5
            allow_right = true
          when 6
            allow_left = true
          when 7
            allow_up = true
          when 8
            allow_down = true
          when 9
            allow_down = allow_up = true
            #includes left right crossing bits
          when 10
            allow_left = allow_right = true
          when 11
            allow_up = allow_left = true
          when 12
            allow_down = allow_left = true
          when 13
            allow_down = allow_right = true
          when 14
            allow_right = true
            allow_up = true
        else
        end

        arrow_keys = gl.keyspressed(KEY_W, KEY_A, KEY_S, KEY_D, KEY_UP, KEY_DOWN)
        speed = (37.0) * (delta_time * 0.1)

        arrow_keys.each do |arrow_key|
          case arrow_key
            when KEY_W
              player_velocity[2] += speed
              got_ud = true
            when KEY_S
              player_velocity[2] -= speed
              got_ud = true
            when KEY_A
              player_velocity[0] += speed
              got_lr = true
            when KEY_D
              player_velocity[0] -= speed
              got_lr = true
          end

          max_v = 1.5
          if player_velocity[2] > max_v
            player_velocity[2] = max_v
          end

          if player_velocity[0] > max_v
            player_velocity[0] = max_v
          end

          if player_velocity[0] < -max_v
            player_velocity[0] = -max_v
          end

          if player_velocity[2] < -max_v
            player_velocity[2] = -max_v
          end
        end

        some_slow_down_percent = 1.85

        if !got_ud
          if player_velocity[2] > 0.15
            player_velocity[2] -= speed * some_slow_down_percent
            if player_velocity[2] < 0
              player_velocity[2] = 0
            end
          elsif player_velocity[2] < -0.15
            player_velocity[2] += speed * some_slow_down_percent
            if player_velocity[2] > 0
              player_velocity[2] = 0
            end
          else
            player_velocity[2] = 0
          end
        end

        if !got_lr
          if player_velocity[0] > 0.15
            player_velocity[0] -= speed * some_slow_down_percent
            if player_velocity[0] < 0
              player_velocity[0] = 0
            end
          elsif player_velocity[0] < -0.15
            player_velocity[0] += speed * some_slow_down_percent
            if player_velocity[0] > 0
              player_velocity[0] = 0
            end
          else
            player_velocity[0] = 0
          end
        end

        at_left_right_limit = ((nx - px))
        at_up_down_limit = ((ny - py))

        within_left_right = !(at_left_right_limit.abs > 0.06)
        within_up_down = !(at_up_down_limit.abs > 0.06)

        going_left_and_can_go_left = (within_up_down && (at_left_right_limit > 0) && allow_left)
        going_right_and_can_go_right = (within_up_down && (at_left_right_limit < 0) && allow_right)

        going_up_and_can_go_up = (within_left_right && (at_up_down_limit > 0) && allow_up)
        going_down_and_can_go_down = (within_left_right && (at_up_down_limit < 0) && allow_down)

        ##if (!within_left_right)
        ###&& !(within_left_right && pass_y)
        ###&& player_velocity[0].abs > 0.0 #|| (!within_left_right && pass_y)
        ##  #if enforce_x
        ##    log!(:flip_x)
        ##    player_velocity[0] *= -1.0
        ##  #end
        ##end
        #log!(:AAA, player_at_shape, player_position[0], px, going_left_and_can_go_left, allow_left, "=", going_right_and_can_go_right, allow_right)

        enforce_x = enforce_y = false

        #enforce_x = ((!within_left_right && (allow_up || allow_down)) && !(within_up_down && (allow_left || allow_right))) || (((at_left_right_limit > 0.04) && !allow_left) || ((at_left_right_limit < 0.04) && !allow_right))
        #enforce_x = ((!within_left_right && (allow_up || allow_down))) || (((at_left_right_limit > 0.04) && !allow_left) || ((at_left_right_limit < 0.04) && !allow_right))

        enforce_x = ((at_left_right_limit > 0.04) && !allow_left) || ((at_left_right_limit < -0.04) && !allow_right)

        #(!within_left_right && !going_left_and_can_go_left && !going_right_and_can_go_right) && !(within_left_right && (allow_up || allow_down))
        enforce_y = false 
        #(!within_up_down && !going_up_and_can_go_up && !going_down_and_can_go_down) && !(within_up_down && (allow_left || allow_right))

#        if (going_left_and_can_go_left || going_right_and_can_go_right)
#        else
#          if player_velocity[0] != 0
#            #[:flip_x, -0.5000869081568322, -1, false, false]
#            #[:flip_x, nil, -0.5011129386967751, -1, false, false, "=", false, false]
#            #[:flip_x, nil, -0.5003200121841979, -1, false, false, "=", false, false]
#
##[:flip_x_AAA, 2, -0.553187692366191, -0.05983971140090576, 0.3577733723312623, 0, false, true, "=", false, true]
##[:flip_x_BBB, 2, 0.553187692366191, -0.05983971140090576, 0.3577733723312623, 0, false, true, "=", false, true]
##[:flop_y_AAA, 2, 1.263242925910164, -0.05983971140090576, 0.3577733723312623, 0, false, true, "=", false, false]
##[:flop_y_BBB, 2, -1.263242925910164, -0.05983971140090576, 0.3577733723312623, 0, false, true, "=", false, false]
#            #log!(:flip_x_AAA, player_at_shape, player_velocity[0], player_position[0], player_position[2], px, going_left_and_can_go_left, allow_left, "=", going_right_and_can_go_right, allow_right)
#            #player_velocity[0] *= -1.0
#            #log!(:flip_x_BBB, player_at_shape, player_velocity[0], player_position[0], player_position[2], px, going_left_and_can_go_left, allow_left, "=", going_right_and_can_go_right, allow_right)
#            enforce_x = true
#          end
#        end
#
#        if (going_up_and_can_go_up || going_down_and_can_go_down)
#        else
#          if player_velocity[2] != 0
#            #log!(:flop_y_AAA, player_at_shape, player_velocity[2], player_position[0], player_position[2], px, going_up_and_can_go_up, allow_up, "=", going_down_and_can_go_down, allow_down)
#            #player_velocity[2] *= -1.0
#            #log!(:flop_y_BBB, player_at_shape, player_velocity[2], player_position[0], player_position[2], px, going_up_and_can_go_up, allow_up, "=", going_down_and_can_go_down, allow_down)
#            enforce_y = true
#          end
#        end

        if enforce_x || enforce_y
          log!(:xxx)
          line_x1 = 0.0
          line_y1 = 0.0

          line_x2 = 0.0
          line_y2 = 0.0

          if enforce_x #player_velocity[0].abs > player_velocity[2].abs
            # left right
            log!(:a111)

            line_x1 = 0.0
            line_y1 = -1.0

            line_x2 = 0.0
            line_y2 = 1.0
          elsif enforce_y #player_velocity[0].abs < player_velocity[2].abs
            log!(:b222)

            line_x1 = -1.0
            line_y1 = 0.0

            line_x2 = 1.0
            line_y2 = 0.0
          #else
          #  if ((player_velocity[0] > 0) && (player_velocity[2] > 0)) || ((player_velocity[0] < 0) && (player_velocity[2] < 0))
          #    log!(:AAA)
          #    line_x1 = -1.0
          #    line_y1 = 1.0

          #    line_x2 = 1.0
          #    line_y2 = -1.0
          #  else
          #    log!(:BBB)
          #    line_x1 = -1.0
          #    line_y1 = -1.0

          #    line_x2 = 1.0
          #    line_y2 = 1.0
          #  end
          end

          normalY = line_x2 - line_x1
          normalX = line_y1 - line_y2
          normalLength = Math.sqrt(normalX * normalX + normalY * normalY)

          normalX = normalX / normalLength
          normalY = normalY / normalLength

          #rayTipX
          iX = 0.0
          iY = 0.0

          rayTipX = player_velocity[0]
          rayTipY = player_velocity[2]

          rayX = rayTipX - iX
          rayY = rayTipY - iY

          dotProduct = (rayX * normalX) + (rayY * normalY)
          dotNormalX = dotProduct * normalX
          dotNormalY = dotProduct * normalY

          reflectedRayTipX = rayTipX - (dotNormalX * 2)
          reflectedRayTipY = rayTipY - (dotNormalY * 2)

          #log!(:flop_AAA, player_at_shape, player_velocity[0], player_position[2], player_position[2], px, going_up_and_can_go_up, allow_up, "=", going_down_and_can_go_down, allow_down)
          player_velocity[0] = reflectedRayTipX
          player_velocity[2] = reflectedRayTipY
          #log!(:flop_BBB, player_at_shape, player_velocity[0], player_position[2], player_position[2], px, going_up_and_can_go_up, allow_up, "=", going_down_and_can_go_down, allow_down)

          #[:flop_AAA, 2, 0, -0.05999770552850488, -0.05999770552850488, 0, false, true, "=", false, false]
          #[:flop_BBB, 2, 0.0, -0.05999770552850488, -0.05999770552850488, 0, false, true, "=", false, false]

        end

        #pass_x = pass_y = false

          #if (at_left_right_limit < 0 && allow_right) && within_up_down
          #  pass_x = true
          #elsif (at_left_right_limit > 0 && allow_left) && within_up_down
          #  pass_x = true
          #else
          #  if enforce_bounds
          #    #player_velocity[0] *= -1.0
          #    #player_velocity[2] *= -1.0
          #    enforce_x = true
          #  end
          #end

          #if (at_up_down_limit > 0 && allow_up) && within_left_right
          #  pass_y = true
          #elsif (at_up_down_limit < 0 && allow_down) && within_left_right
          #  pass_y = true
          #elsif (within_up_down && pass_x)
          #else
          #  if enforce_bounds
          #    #player_velocity[0] *= -1.0
          #    #player_velocity[2] *= -1.0
          #    enforce_y = true
          #  end
          #end


        #if (!(within_left_right) && !(at_up_down_limit > 0 && allow_up)) || (!(within_left_right) && !(at_up_down_limit < 0 && allow_down))
        ##&& !(within_up_down && pass_x)
        ##&& player_velocity[2].abs > 0.0 #|| (!within_up_down && pass_x)
        #  #if enforce_y
        #    log!(:flop_y)
        #    player_velocity[2] *= -1.0
        #  #end
        #end

        if !player_at_shape
          player_velocity[0] = 0
          player_velocity[2] = 0
        else
          player_position[0] = nx
          player_position[2] = ny
        end

        camera_position[0] = player_position[0] + ((0.033) * player_velocity[0])
        camera_position[2] = player_position[2] - (1.0)

        camera_target = [player_position[0] - (0.01), player_position[1], player_position[2] + (0.01)]

        gl.lookat(1, *camera_position, *camera_target, fovy)

        ((px-maze_draw_distance)..(px+maze_draw_distance)).each do |x|
          ((py-maze_draw_distance)..(py+maze_draw_distance)).each do |y|
            if x>=0 && x<maze_s && y>=0 && y<maze_s
              cell = maze[x, y]
              unless cell == 0
                primary = (cell & Theseus::Maze::PRIMARY)
                if shape = shapes[primary]

                  
                  shapes[primary].deltap(x, 0, y)
                  shapes[primary].draw(false)
                end
              end
            end
          end
        end

        cube.deltap(player_position[0], player_position[1], player_position[2])
        cube.draw(false)
      }

      gl.twod {
        gl.button(50.0, 50.0, 250.0, 20.0, "maze #{total_msg} #{player_at_shape} #{at_up_down_limit} #{at_left_right_limit} #{player_position}") {
          gl.emit({"x" => "y"})
          enforce_bounds = !enforce_bounds
        }
      }
    }
  }
}

end
