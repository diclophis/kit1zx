#

if false

Wkndr.play { |gl|
  player_position = [0.0,0.0,0.0]
  camera_position = [7.0,7.0,9.0]
  fovy = 30.0

  gl.lookat(1, *camera_position, *player_position, fovy)

  flowers = []

  flowers << Model.new("resources/tri001.obj", "", 1.0)
  flowers << Model.new("resources/cube.obj", "", 0.5)
  flowers << Model.new("resources/road-corner.obj", "resources/road-corner.mtl", 0.76)
  flowers << Model.new("resources/rando.obj", "", 0.76)
  flowers << Model.new("resources/coin.obj", "", 2.0)

  #flower = Model.new("resources/Prop_Fence_Gate_1.obj", "", 33.0)

  total_msg = 0
  flower_index = 0

  gl.event { |typed_msg|
    total_msg += 1
  }

  gl.update { |global_time, delta_time|
    gl.drawmode {
      gl.threed {
        #flower.deltas(0.0001, 0.0001, 0.0001)
        #flower.deltap(player_position[0], player_position[1], player_position[2])
        flower = flowers[(flower_index) % flowers.length]

        #flower.deltar(Math.cos(-global_time * 0.5), Math.sin(global_time), Math.cos(global_time * 1.0), global_time * 33.0)
        flower.deltar(0, 1, 0, global_time * -100.0)
        flower.draw(false)
      }

      gl.twod {
        gl.draw_fps(0, 0)
        gl.button(50.0, 50.0, 250.0, 20.0, "maze #{total_msg}") {
          gl.emit({"x" => "y"})
          flower_index += 1
        }
      }
    }
  }
}

else

Wkndr.play { |gl|
  srand(2)

  size = 0.1
  shapes = {}
  shape_translate_table = {}
  enforce_bounds = true

  16.times { |i|
    ii = begin
      case i
        when 1
          8
        when 2
          7
        when 3
          9
        when 4
          6
        when 5
          12
        when 6
          11
        when 7
          3
        when 8
          5
        when 9
          13
        when 10
          14
        when 11
          4
        when 12
          10
        when 13
          1
        when 14
          2
        when 15
          0
      else
        nil
      end
    end
    
    if ii
      #ii = 0
      shape_translate_table[i] = ii
      shape_file = "resources/shape-#{ii}.obj"
      #log!(:shape, shape_file)
      shapes[i] = Model.new(shape_file, "", 1.0)
    end
  }

  maze_s = 100
  braid = 0
  weave = 0
  sparse = 0

  ## generate a 10x10 orthogonal maze and print it to the console
  maze = Theseus::OrthogonalMaze.generate(:width => maze_s, :height => maze_s, :braid => braid, :weave => weave, :wrap => "xy", :sparse => 100)

  cube = Cube.new(size, size, size, 1.0)

  player_position = [0.0,0.125,0.0]
  player_velocity = [0.0, 0.0, 0.0]
  camera_position = [0.0,1.5,0.0]

  fovy = 60.0
  maze_draw_distance = 3

  gl.lookat(1, *camera_position, *player_position, fovy)

  total_msg = 0

  gl.event { |typed_msg|
    total_msg += 1
  }

  player_at_shape = ""

  gl.update { |global_time, delta_time|
    gl.drawmode {
      gl.threed {
        got_lr = got_ud = false

        px = (player_position[0]).round.to_i
        py = (player_position[2]).round.to_i
        #log!(:pxpy, px, py)
        player_at_shape_cell = maze[px, py]
        player_at_shape = shape_translate_table[(player_at_shape_cell & Theseus::Maze::PRIMARY)]

        allow_up = false
        allow_down = false
        allow_left = false
        allow_right = false

        case player_at_shape
          when 0
            allow_up = allow_down = allow_left = allow_right = true
          when 1
            allow_down = allow_left = allow_right = true
          when 2
            allow_up = allow_left = allow_right = true
          when 3
            allow_up = allow_down = allow_left = true
          when 4
            allow_up = allow_down = allow_right = true
          when 5
            allow_right = true
          when 6
            allow_left = true
          when 7
            allow_up = true
          when 8
            allow_down = true
          when 9
            allow_down = allow_up = true
            #includes left right crossing bits
          when 10
            allow_left = allow_right = true
          when 12
            allow_down = allow_left = true
          when 14
            allow_right = true
            allow_up = true
          when 13
            allow_down = allow_right = true
          when 11
            allow_up = allow_left = true
        else
        end

        arrow_keys = gl.keyspressed(KEY_W, KEY_A, KEY_S, KEY_D, KEY_UP, KEY_DOWN)
        speed = (37.0) * (delta_time * 0.1)

        arrow_keys.each do |arrow_key|
          case arrow_key
            when KEY_W
              player_velocity[2] += speed
              got_ud = true
            when KEY_S
              player_velocity[2] -= speed
              got_ud = true
            when KEY_A
              player_velocity[0] += speed
              got_lr = true
            when KEY_D
              player_velocity[0] -= speed
              got_lr = true
          end

          max_v = 1.5
          if player_velocity[2] > max_v
            player_velocity[2] = max_v
          end

          if player_velocity[0] > max_v
            player_velocity[0] = max_v
          end

          if player_velocity[0] < -max_v
            player_velocity[0] = -max_v
          end

          if player_velocity[2] < -max_v
            player_velocity[2] = -max_v
          end
        end

        some_slow_down_percent = 1.85

        at_up_down_limit = ((player_position[2] - py))
        at_left_right_limit = ((player_position[0] - px))

        within_left_right = !(at_left_right_limit.abs > 0.06)
        within_up_down = !(at_up_down_limit.abs > 0.06)

        if !within_left_right
          if (at_left_right_limit < 0 && allow_right) && within_up_down
          elsif (at_left_right_limit > 0 && allow_left) && within_up_down
          else
            if enforce_bounds
              player_velocity[0] *= -1.1
            end
          end
        end

        if !within_up_down
          if (at_up_down_limit > 0 && allow_up) && within_left_right
          elsif (at_up_down_limit < 0 && allow_down) && within_left_right
          else
            if enforce_bounds
              player_velocity[2] *= -1.1
            end
          end
        end

        if !got_ud
          if player_velocity[2] > 0.15
            player_velocity[2] -= speed * some_slow_down_percent
            if player_velocity[2] < 0
              player_velocity[2] = 0
            end
          elsif player_velocity[2] < -0.15
            player_velocity[2] += speed * some_slow_down_percent
            if player_velocity[2] > 0
              player_velocity[2] = 0
            end
          else
            player_velocity[2] = 0
          end
        end

        if !got_lr
          if player_velocity[0] > 0.15
            player_velocity[0] -= speed * some_slow_down_percent
            if player_velocity[0] < 0
              player_velocity[0] = 0
            end
          elsif player_velocity[0] < -0.15
            player_velocity[0] += speed * some_slow_down_percent
            if player_velocity[0] > 0
              player_velocity[0] = 0
            end
          else
            player_velocity[0] = 0
          end
        end

        player_position[2] += player_velocity[2] * delta_time
        player_position[0] += player_velocity[0] * delta_time

        camera_position[0] = player_position[0] + ((0.033) * player_velocity[0])
        camera_position[2] = player_position[2] - (1.0)

        camera_target = [player_position[0] - (0.01), player_position[1], player_position[2] + (0.01)]

        gl.lookat(1, *camera_position, *camera_target, fovy)

        ((px-maze_draw_distance)..(px+maze_draw_distance)).each do |x|
          ((py-maze_draw_distance)..(py+maze_draw_distance)).each do |y|
            if x>=0 && x<maze_s && y>=0 && y<maze_s
              cell = maze[x, y]
              unless cell == 0
                primary = (cell & Theseus::Maze::PRIMARY)
                if shape = shapes[primary]

                  
                  shapes[primary].deltap(x, 0, y)
                  shapes[primary].draw(false)
                end
              end
            end
          end
        end

        cube.deltap(player_position[0], player_position[1], player_position[2])
        cube.draw(false)
      }

      gl.twod {
        gl.button(50.0, 50.0, 250.0, 20.0, "maze #{total_msg} #{player_at_shape}") {
          gl.emit({"x" => "y"})
          enforce_bounds = !enforce_bounds
        }
      }
    }
  }
}

end
